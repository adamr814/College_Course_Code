:: 9/25/23 ::

Memory Management

**Address space:**
we have 2 types of address spaces:
1. physical address - memory addresses seen by the memory management unit (MMU). ie the actual hardware address
2. logical address - address location generated by CPU

**Address Binding:**
when a program is loaded into memory the addresses of data and instructions must be mapped into memory locations. This is called address binding. The 3 methods of address binding are:

1. compile time - The compiler generates absolute memory addresses (i.e. DOS .COM files). these programs can only reside at a specific location in memory and if that location is already occupied, the program cannot load.
2. Load-time - the compiler generates *relocatable* code. with relocatable code each memory address is relative to a base address. So when the program is loaded, it can load into any memory location
3. Execution-time - the compiler generates *relocatable* code. However, since it is possible that the program will be moved to different memory locations during its execution phase, the base address may change. Requires special hardware

**Address space and binding**
Compile-time binding - logical addresses (generated by the CPU) and the physical addresses are the same.

Load-time binding - logical addresses and the physical addresses being the same (once the program is loaded)

Execution-time binding - logical addresses being different than the physical addresses. while the program  runs the MMU re-maps the logical addresses to the correct physical address.

**Dynamic Memory Management**
up until the 1960's (batch OS's) it was common for one program to reside in memory. as programs outgrew the available memory methods were developed to conserve memory usage. these include:
- dynamic loading - only the main program loads at startup. routines are not loaded until needed
- dynamic linking- similar to dynamic loading. the compiler includes a stub for each routine used from the dynamic linked library (.DLL) in the user's program. The stub has information as how to load the routine. When a routine from the DLL is needed, it is loaded into memory and the stub is replaced with the memory address of the routine.
- overlays - only a portion of the program is kept in memory. when another part of the program is required, it is loaded and overwrites the existing portion of the program that was in memory.
- virtual memory - similar to overlays, except the OS manages the process

**Memory VS CPU Usage:**
with multiprogramming we can make better use of the CPU. However, the assumption is not always valid. On average, programs are 80% I/O dependent. Therefore, it is very likely that at any given time, all of the processes will be waiting for I/O and the CPU will have nothing to do. The probability that the CPU will be idle at any given time is:
P^n

and CPU utilization is:
1 - P^n

P = I/O dependence
n = # of processes

we have assumed that the processes are independent. this is not completely accurate. But, the model does give us a good idea as to what is going on.

even though the model is simple it can still be used to make approximate predictions about CPU usage.
1. assume we have 1meg RAM and the OS requires 200K and each of the 4 users requires about 200K. With and average I/O dependency of 80%, we get a CPU utilization of about 68%
2. if we add another 1meg RAM, we can increase our degree of multiprogramming to 9 and we can raise our CPU utilization to about 87%. We've increased CPU utilization by about 28%
3. If we add another 1meg Ram, we can increase our degree of multiprogramming to 14 and we can raise our CPU utilization to about 96%. We've further increased CPU utilization to about 10%.